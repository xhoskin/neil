//--------------------------------------------------------------
// `` Лист на неделю
//---------------------------------------------------------------------
  
qa;.q         //повторяем в макросе последние движения
22qa          //применяем заведомо больше раз чем надо
V:norm @a     //применить макрос ко всем строкам выделения
qA j q        //добавить команды в конец макроса (если забыли)
//Как применить макрос ко всем открытым файлам:
:argdo norm @a    //Параллельный способ: быстро, но если будет ошибка, мы этого сразу не заметим
:qA :next q       //Последовательный способ: добавляем :next
                  //долго, но применяя макрос файл за файлом нам легче обнаружить ошибку

//пронумеровать строки файла
:let i=1          //создаем переменную
qi                //начинаем записывать макрос
I<C-r>=i          //вставляем ее значение
:let i += 1       //увеличиваем значение
q VG norm @i      //закрываем запись и применяем макрос

//буферы
5<C-^>              //5-й буфер в списке
//Обозначения в списке буферов
%           //буфер, открытый в текущем окне
#           //файл, на который мы переключимся по C-^
a	          //буфер, файл которого загрузился в память [active] 
+           //измененный буфер
x           //ошибки записи в буфере

//--------------------------------------------------------------
// `` Лист редких команд
//--------------------------------------------------------------


//история команд
:ju[mps]            //вывести список прыжков
:changes            //вывести список изменений
//Visual Mode
<C-g>               //переключает Visual Mode в Select Mode (win-like)
O                   //в Visual Block Mode переходит на начало|конец строки выделения
//командная строка
:shell      //запустить cmd|bash с возможность выполнить несколько команд
:read !dir  //вставить результат выполнения команды
<C-r><C-w>          //вставить в командную строку слово под курсором
//файлы
args */*.txt        //открыть все *.txt в текущей и всех вложенных папках
:fin[d] reset.css   //найти и открыть файл в папках, указаных в $path
:path css/**        //задать $path */
:!md %:h :w         //создаем несуществую папку и сохраняем в нее наш файл
:e!         //переоткрыть файл заново, не сохраняя его
//вкладки
<C-w>T              //переместить текущее окно в новую вкладку
:tabo[nly]          //закрыть все вкладки, кроме текущей
//перемещение по изменениям
//метки
``            //к месту последнего прыжка в файле
`.            //к месту последнего Change Mode
`^            //к месту последнего Insert Mode
`[            //к началу последнего копирования (или правки)
`]            //к концу последнего копирования (или правки)
`<            //к началу последнего Visual Selection
`>            //к концу последнего визуального выделения
//регистры
:reg          //вывести содержимое регистров
"_d           //удалить минуя регистр (удалить в Black hole register) 
//стандартные регистры
"             //безымянный регистр (только что удаленный или скопированный текст)
0             //yank-регистр (только что скопированный текст)
*             //буфер обмена
+             //буфер обмена
%             //путь и имя открытого файла 
#             //путь к открытому файлу
/             //последняя строка поиска
:             //последняя Ex-команда
-             //последнее удаление (меньше строки) 
.             //последний вставленный текст



//--------------------------------------------------------------------
// `` Предстоит выучить
//---------------------------------------------------------------------

// regexp switchers
\c                //временно включить чувствительность к регистру
\v                //временно включить perl-синтаксис регекспов [very magic]
\V                //временно отключить все спецсимволы [very nomagic]

// regexp синтаксис
\_s               //пробел или конец строки
<>                //границы слов
%()               //не запоминать содержимое скобок
\zs | \ze         //начало и конец паттерна (аналог perl lookaround expression)
\v"\zs[.*]\ze"    //найти текст, заключенный в кавычки 
=escape(@u, getcmdtype().'\')    //экранировать все слеши в регистре u


// Поиск
let nows | ws     //выкл. или вкл. поиск сначала если достигнут конец файла
:%s///gn          //флаг /n - сосчитать количество вхождений в файле
/; /e             //флаг /e - курсор будет находится на конце вхождения (по умолч. на начале)
//                //повторить последнюю строку поиска вперед 
??                //повторить последнюю строку поиска назад
//e               //повторить посл. поиск, но курсор будет на конце вхождения

// Замена
"используй q/ чтоб создавать сложные регекспы методом итераций"
s//{change-text}/      //заменить все вхождения последней строки поиска на нужный текст
%s/set/let/gc     //флаг /c - спрашивать перед каждой заменой
q                 //quit - выйти из режима замен
l                 //last - заменить это вхождение и выйти
a                 //all — заменить все вхождения
<C-e>             //прокрутить экран вверх
<C-y>             //прокрутить экран вниз 

%s//\=@0/g        //заменить на содержимое регистра 0
g&                //повторить послендюю команду замены ко всему файлу
:&&               //повторить послендюю команду замены
:%s//\=submatch(0)-1/g      //произвести арифметические действия с найденным числом

:%s/\v(<man>|<dog>)/\={"dog":"man","man":"dog"}[submatch(1)]/g    //заменить "man" на "dog", "dog" на "man"
set hidden                  //разрешает перемещаться по буферам не сохраняя
:argdo %s//Practical/g      //заменить во всех открытых файлах
:argdo %s//Practical/ge     //флаг /c - не показывать сообщения об ошибках

:Qargs                      //перенести файлы из quickfix-list в args-list
:args update                //сохранить файлы, которые были изменены
:Qargs | argdo %s//Practical/g | update       // выполнить все вышеперечисленные команды
